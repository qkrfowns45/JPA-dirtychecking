영속성 컨텍스트와 더티 체킹

 controller로 request를 받고 response를 한다. 이때 컨트롤러에서는 CRUD(Insert, Update, Delete, Select)를 처리한다.
DB에 접근하여 CRUD를 진행할때 JPA를 통해 접근한다. 

 JPA에는 영속성 컨텍스트가 있는데 1차캐시란 것이 존재하고 객체정보들이 쌓인다.
(ex-controller에서 객체를 save로 전달하면 JPA에 1차캐시에 쌓이고 이 객체를 영속화 한다. 영속화 된 객체를 DB에 넣고 이것을 flush라고 한다.)
flush는 쉽게 버퍼를 비운다고 생각하면 된다. flush를 하면 데이터를 집어 넣고 1차캐시에 남겨놓는 특징이 있다.
controller에서 select를 진행할때 flush를 진행한 상태면 DB까지 갔다오지 않고 1차캐시에 남겨놨던 객체를 들고온다.(DB를 안갔다와서 부하가 덜 걸린다.)

update는 조회할때 DB에서 가져온 객체를 1차캐시에 쌓고 영속화를 시킨다. 그 데이터를 controller로 들고온다.
들고온 데이터들을 변경하고 save를 진행할때 캐시에 남아있는 영속화된 데이터와 비교하고 1차캐시 객체를 변경하고 DB에 저장한다.

더티체킹(Dirty Checking)이란 상태 변경 검사이다.
JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 모든 엔티티 객체를 데이터베이스 반영한다.
그렇기 때문에 값을 변경한 뒤, save 하지 않더라도 DB에 반영되는 것이다.

이러한 상태 변경 검사의 대상은 영속성 컨텍스트가 관리하는 엔티티에만 적용된다.(준영속, 비영속된 객체X)

더티체킹(Dirty Checking) 원리:
    · 영속성 컨텍스트란 서버와 DB사이에 존재한다.
    · JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둔다.(일종의 스냅샷)
    · 트랜잭션이 끝나고 flush할 때 스냅샷과 현재 엔티티를 비교해 변경된 엔티티를 찾아낸다.
    · JPA는 변경된 엔티티를 DB단에 반영하여 한번에 쿼리문을 날려준다.
